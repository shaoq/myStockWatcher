## Context

当前 `stock_zh_a_spot_em()` 每次调用都会从东方财富下载 5000+ 只股票的全量数据，导致：
- 响应慢（进度条显示）
- 重复请求浪费带宽
- 用户体验差

## Goals / Non-Goals

**Goals:**
- 共享全量数据缓存，避免重复下载
- 智能缓存时效控制（交易时间 5 分钟，非交易时间到次日开盘）
- 估值请求响应时间大幅缩短
- 透明化：用户不再看到进度条

**Non-Goals:**
- 不修改前端代码
- 不改变估值 API 接口签名
- 不引入 Redis 等外部缓存依赖

## Decisions

### 1. 缓存存储位置：内存字典 + 全局变量

**选择理由：**
- 简单，无需额外依赖
- 单进程场景足够用
- 后端重启自动清空缓存（符合预期）

**替代方案：**
- SQLite 缓存：持久化，但增加复杂度
- Redis：分布式场景，但需要额外部署

### 2. 缓存时效策略

```
┌─────────────────────────────────────────────────────────────────┐
│                      缓存时效判断                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  is_cache_valid(cache_time):                                    │
│      if cache_time is None:                                     │
│          return False  # 无缓存                                 │
│                                                                 │
│      now = current_time()                                       │
│      age = now - cache_time                                     │
│                                                                 │
│      if is_trading_time(now):                                   │
│          # 交易时间内：5 分钟有效期                              │
│          return age < 5 minutes                                 │
│      else:                                                      │
│          # 非交易时间：缓存到下一交易日开盘                      │
│          next_open = get_next_trading_open()                    │
│          return now < next_open                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 3. 缓存数据结构

```python
# 全局缓存结构
_spot_data_cache = {
    "data": DataFrame,        # 全量股票数据
    "fetched_at": datetime,   # 获取时间
    "source": "eastmoney",    # 数据来源
}
```

### 4. 调用流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    估值获取流程                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  get_valuation_metrics(symbol):                                 │
│      1. 检查缓存是否存在且有效                                  │
│         ├─ 有效 → 从缓存 DataFrame 中筛选目标股票               │
│         └─ 无效/不存在 → 下载全量数据，更新缓存                  │
│                                                                 │
│      2. 从 DataFrame 中提取估值指标                             │
│                                                                 │
│      3. 返回结果                                                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## Risks / Trade-offs

- **内存占用** → 全量 DataFrame 约 5-10MB，可接受
- **多进程不一致** → 如使用多 worker，各进程独立缓存，可能导致短暂不一致（可接受）
- **缓存过期判断复杂** → 使用简化逻辑，非交易时间统一到次日开盘
